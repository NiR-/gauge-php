<?php
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# source: api_v2.proto

namespace Gauge\Messages;

use Google\Protobuf\Internal\GPBType;
use Google\Protobuf\Internal\RepeatedField;
use Google\Protobuf\Internal\GPBUtil;

/**
 * <pre>
 * ExecutionRequest defines the structure of requests that the API's consumers can send to request execution of specs/scenarios
 * </pre>
 *
 * Protobuf type <code>gauge.messages.ExecutionRequest</code>
 */
class ExecutionRequest extends \Google\Protobuf\Internal\Message
{
    /**
     * <pre>
     * Each ExecutionRequest can ask to execute multiple spec files or multiple scenarios in a spec or a directory or all
     * </pre>
     *
     * <code>repeated string specs = 1;</code>
     */
    private $specs;
    /**
     * <pre>
     * Tag expression to filter specs and scenarios during execution. Default: ""
     * </pre>
     *
     * <code>string tags = 2;</code>
     */
    private $tags = '';
    /**
     * <pre>
     * The working directory for gauge.
     * </pre>
     *
     * <code>string workingDir = 3;</code>
     */
    private $workingDir = '';
    /**
     * <pre>
     * Environment to choose for gauge.
     * </pre>
     *
     * <code>string env = 4;</code>
     */
    private $env = '';
    /**
     * <code>.gauge.messages.ExecutionRequest.LogLevel logLevel = 5;</code>
     */
    private $logLevel = 0;
    /**
     * <pre>
     * Whether to run gauge in parallel mode.
     * </pre>
     *
     * <code>bool isParallel = 6;</code>
     */
    private $isParallel = false;
    /**
     * <pre>
     * If isParallel is true, this specifies how many parallel streams to run.
     * </pre>
     *
     * <code>int32 parallelStreams = 7;</code>
     */
    private $parallelStreams = 0;
    /**
     * <pre>
     * If true, sorts execution of specifications alphabetically
     * </pre>
     *
     * <code>bool sort = 8;</code>
     */
    private $sort = false;
    /**
     * <code>.gauge.messages.ExecutionRequest.Strategy strategy = 9;</code>
     */
    private $strategy = 0;
    /**
     * <pre>
     * Specify against which rows of datatable the scenarios should be executed
     * </pre>
     *
     * <code>string tableRows = 10;</code>
     */
    private $tableRows = '';
    /**
     * <pre>
     * Signals Gauge that the execution is being debugged, usually via an identifier
     * </pre>
     *
     * <code>bool debug = 11;</code>
     */
    private $debug = false;

    public function __construct() {
        \GPBMetadata\ApiV2::initOnce();
        parent::__construct();
    }

    /**
     * <pre>
     * Each ExecutionRequest can ask to execute multiple spec files or multiple scenarios in a spec or a directory or all
     * </pre>
     *
     * <code>repeated string specs = 1;</code>
     */
    public function getSpecs()
    {
        return $this->specs;
    }

    /**
     * <pre>
     * Each ExecutionRequest can ask to execute multiple spec files or multiple scenarios in a spec or a directory or all
     * </pre>
     *
     * <code>repeated string specs = 1;</code>
     */
    public function setSpecs(&$var)
    {
        GPBUtil::checkRepeatedField($var, \Google\Protobuf\Internal\GPBType::STRING);
        $this->specs = $var;
    }

    /**
     * <pre>
     * Tag expression to filter specs and scenarios during execution. Default: ""
     * </pre>
     *
     * <code>string tags = 2;</code>
     */
    public function getTags()
    {
        return $this->tags;
    }

    /**
     * <pre>
     * Tag expression to filter specs and scenarios during execution. Default: ""
     * </pre>
     *
     * <code>string tags = 2;</code>
     */
    public function setTags($var)
    {
        GPBUtil::checkString($var, True);
        $this->tags = $var;
    }

    /**
     * <pre>
     * The working directory for gauge.
     * </pre>
     *
     * <code>string workingDir = 3;</code>
     */
    public function getWorkingDir()
    {
        return $this->workingDir;
    }

    /**
     * <pre>
     * The working directory for gauge.
     * </pre>
     *
     * <code>string workingDir = 3;</code>
     */
    public function setWorkingDir($var)
    {
        GPBUtil::checkString($var, True);
        $this->workingDir = $var;
    }

    /**
     * <pre>
     * Environment to choose for gauge.
     * </pre>
     *
     * <code>string env = 4;</code>
     */
    public function getEnv()
    {
        return $this->env;
    }

    /**
     * <pre>
     * Environment to choose for gauge.
     * </pre>
     *
     * <code>string env = 4;</code>
     */
    public function setEnv($var)
    {
        GPBUtil::checkString($var, True);
        $this->env = $var;
    }

    /**
     * <code>.gauge.messages.ExecutionRequest.LogLevel logLevel = 5;</code>
     */
    public function getLogLevel()
    {
        return $this->logLevel;
    }

    /**
     * <code>.gauge.messages.ExecutionRequest.LogLevel logLevel = 5;</code>
     */
    public function setLogLevel($var)
    {
        GPBUtil::checkEnum($var, \Gauge\Messages\ExecutionRequest_LogLevel::class);
        $this->logLevel = $var;
    }

    /**
     * <pre>
     * Whether to run gauge in parallel mode.
     * </pre>
     *
     * <code>bool isParallel = 6;</code>
     */
    public function getIsParallel()
    {
        return $this->isParallel;
    }

    /**
     * <pre>
     * Whether to run gauge in parallel mode.
     * </pre>
     *
     * <code>bool isParallel = 6;</code>
     */
    public function setIsParallel($var)
    {
        GPBUtil::checkBool($var);
        $this->isParallel = $var;
    }

    /**
     * <pre>
     * If isParallel is true, this specifies how many parallel streams to run.
     * </pre>
     *
     * <code>int32 parallelStreams = 7;</code>
     */
    public function getParallelStreams()
    {
        return $this->parallelStreams;
    }

    /**
     * <pre>
     * If isParallel is true, this specifies how many parallel streams to run.
     * </pre>
     *
     * <code>int32 parallelStreams = 7;</code>
     */
    public function setParallelStreams($var)
    {
        GPBUtil::checkInt32($var);
        $this->parallelStreams = $var;
    }

    /**
     * <pre>
     * If true, sorts execution of specifications alphabetically
     * </pre>
     *
     * <code>bool sort = 8;</code>
     */
    public function getSort()
    {
        return $this->sort;
    }

    /**
     * <pre>
     * If true, sorts execution of specifications alphabetically
     * </pre>
     *
     * <code>bool sort = 8;</code>
     */
    public function setSort($var)
    {
        GPBUtil::checkBool($var);
        $this->sort = $var;
    }

    /**
     * <code>.gauge.messages.ExecutionRequest.Strategy strategy = 9;</code>
     */
    public function getStrategy()
    {
        return $this->strategy;
    }

    /**
     * <code>.gauge.messages.ExecutionRequest.Strategy strategy = 9;</code>
     */
    public function setStrategy($var)
    {
        GPBUtil::checkEnum($var, \Gauge\Messages\ExecutionRequest_Strategy::class);
        $this->strategy = $var;
    }

    /**
     * <pre>
     * Specify against which rows of datatable the scenarios should be executed
     * </pre>
     *
     * <code>string tableRows = 10;</code>
     */
    public function getTableRows()
    {
        return $this->tableRows;
    }

    /**
     * <pre>
     * Specify against which rows of datatable the scenarios should be executed
     * </pre>
     *
     * <code>string tableRows = 10;</code>
     */
    public function setTableRows($var)
    {
        GPBUtil::checkString($var, True);
        $this->tableRows = $var;
    }

    /**
     * <pre>
     * Signals Gauge that the execution is being debugged, usually via an identifier
     * </pre>
     *
     * <code>bool debug = 11;</code>
     */
    public function getDebug()
    {
        return $this->debug;
    }

    /**
     * <pre>
     * Signals Gauge that the execution is being debugged, usually via an identifier
     * </pre>
     *
     * <code>bool debug = 11;</code>
     */
    public function setDebug($var)
    {
        GPBUtil::checkBool($var);
        $this->debug = $var;
    }

}

